package ru.rdtex.mvd.weapon.model.vo;

import oracle.jbo.Row;
import oracle.jbo.RowSet;
import oracle.jbo.server.ViewObjectImpl;

import ru.rdtex.mvd.weapon.model.am.AppModuleImpl;
import ru.rdtex.mvd.weapon.model.vo.common.TypePersonView;
// ---------------------------------------------------------------------
// ---    File generated by Oracle ADF Business Components Design Time.
// ---    Thu Jul 12 16:41:23 MSD 2012
// ---    Custom code may be added to this class.
// ---    Warning: Do not modify method signatures of generated methods.
// ---------------------------------------------------------------------
public class TypePersonViewImpl extends ViewObjectImpl implements TypePersonView {
    /**
     * This is the default constructor (do not remove).
     */
    public TypePersonViewImpl() {
    }

    /**
     * Returns the bind variable value for type.
     * @return bind variable value for type
     */
    public String gettype() {
        return (String)getNamedWhereClauseParam("type");
    }

    /**
     * Sets <code>value</code> for bind variable type.
     * @param value value to bind as type
     */
    public void settype(String value) {
        setNamedWhereClauseParam("type", value);
    }
    
    public void createRow(String Type) {        
        Row newRow = this.createRow();
        newRow.setNewRowState(Row.STATUS_INITIALIZED);
        newRow.setAttribute("Type", Type);
        //get instance of the above created view object
        TypePersonViewImpl vo = this;
        // to insert row at the end of the table
        //vo.insertRowAtRangeIndex(vo.getRangeSize() - 1, newRow);
        //System.out.println(getCountryView1().getCurrentRowIndex());
        vo.insertRow(newRow);
    }
    
    public void deleteSelectedRows(String Type) {
        this.settype(Type);
        //TypePersonViewImpl vo = this;
        
        //create a second row set to not impact the row set
        //used in ADF
        RowSet duplicateRowSet = this.createRowSet("duplicateRowSet");
        //set rowset to first row to avoid "attempt to access
        //dead row" exception
        duplicateRowSet.first();
        //get the current row of the table to set it back after
        //re-executing the VO
        Row currentRow = this.getCurrentRow();
        boolean currentRowDeleted = false;
        //get all rows that have the transoent attribute
        //"MarkForDelete" set to true
        Row[] rowsToDelete =
            duplicateRowSet.getFilteredRows("DeleteRow", true);
        
        /*Row r = duplicateRowSet.first();
        System.out.println("DeleteRow = " + r.getAttribute("DeleteRow")); 
        //System.out.println("row = " + r.getAttribute("test")); 
        while(duplicateRowSet.hasNext()) {
            r = duplicateRowSet.next();
            System.out.println("DeleteRow = " + r.getAttribute("DeleteRow")); 
            //System.out.println("row = " + r.getAttribute("test")); 
        }*/
        
        if (rowsToDelete.length > 0) {
            //only run throizgh this code if there is something to
            //delete
            for (Row rw : rowsToDelete) {
                //if row is ts marked as the current in VO, set
                //boolean flag
                if (rw.getKey().equals(currentRow.getKey())) {
                    currentRowDeleted = true;
                }
                //remove row - don't yet commit
                rw.remove();
            }
            //re-execute VO
            this.executeQuery();
            //reset current row if it hasn't been deleted
            if (!currentRowDeleted) {
                this.setCurrentRow(currentRow);
            }
            
            //duplicateRowSet.closeRowSet();
        }
        duplicateRowSet.closeRowSet();
    }
}
